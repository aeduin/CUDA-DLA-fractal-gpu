diff --git a/main.cu b/main.cu
index e53e3db..f989129 100644
--- a/main.cu
+++ b/main.cu
@@ -1,7 +1,6 @@
 #include <iostream>
 #include <math.h>
 #include <fstream>
-#define CIRCLE_BORDER 1000 * 1
 
 // #define RANDOM_WALK
 
@@ -21,14 +20,12 @@ typedef struct {
 const float radius = 2.0f;
 const int ceil_radius = (int)radius + ((((float)(int)radius) < radius) ? 1 : 0);
 const float max_speed = 3.0f;
-const int particle_count = 4096 * 1;
+const int particle_count = 4096 * 8;
 
-const int grid_size = 1024 * 2;
+const int grid_size = 1024 * 8;
 const int grid_width = grid_size;
 const int grid_height = grid_size;
 
-using ullong = unsigned long long;
-
 __device__ int grid[grid_height][grid_width];
 __constant__ Veci2D* circle_indices;
 __constant__ int circle_indices_length;
@@ -36,17 +33,11 @@ __device__ int border_left;
 __device__ int border_right;
 __device__ int border_top;
 __device__ int border_bottom;
-__device__ int smallest_distance_to_center;
-__device__ float debug = -1.0;
-__device__ ullong total_static_particles;
-__device__ ullong weight_center_x;
-__device__ ullong weight_center_y;
 
 void VecAdd();
 void simulate();
 void tick(Particle* particles, int tick_count);
 __device__ int random_int(int min, int max, uint seed);
-__device__ void make_static(Particle* particle, int tick_count, float modulo_x, float modulo_y);
 
 #define print(message) std::cout << message << std::endl
 
@@ -75,22 +66,11 @@ __global__ void init_grid_negative() {
 
 // sets the center of the grid to 0
 __global__ void init_grid_center() {
+    grid[grid_height / 2][grid_width / 2] = 0;
     border_top = grid_height / 2;
     border_bottom = grid_height / 2;
     border_left = grid_width / 2;
     border_right = grid_width / 2;
-    smallest_distance_to_center = CIRCLE_BORDER * CIRCLE_BORDER;
-
-    if(CIRCLE_BORDER < 0) {
-        grid[grid_height / 2][grid_width / 2] = 0;
-    }
-    else {
-        // init weight center
-        int center_bias = 10;
-        total_static_particles = center_bias;
-        weight_center_x = (grid_width / 2) * center_bias;
-        weight_center_y = (grid_height / 2) * center_bias;
-    }
 }
 
 // outputs the grid (and its widht/height) to a file
@@ -133,7 +113,7 @@ void output_grid() {
 }
 
 __device__ uint hash(uint x) {
-    const uint seed = 1324567967;
+    const uint seed = 1324567967 + 2;
     x += seed;
     x = ((x >> 16) ^ x) * seed;
     x = ((x >> 16) ^ x) * seed;
@@ -158,7 +138,7 @@ __device__ float random_float(uint seed) {
 }
 
 __device__ void randomize_speed(Particle* particle, int direction_seed, int speed_seed) {
-    float direction = M_PI * 2000.0f * random_float(direction_seed);
+    float direction = M_PI * 2.0f * random_float(direction_seed);
     float speed = random_float(speed_seed) * max_speed;
 
     particle->vertical_speed = cosf(direction) * speed;
@@ -171,23 +151,13 @@ __device__ void randomize_particle(Particle* particle) {
     int center_width = border_right - border_left;
     int center_height = border_bottom - border_top;
 
-    if(CIRCLE_BORDER < 0) {
-        particle->x = random_int(0, grid_width - center_width, seed + 0);
-        particle->y = random_int(0, grid_height - center_height, seed + 1);
-
-        if(particle->x > border_left) {
-            particle->x += center_width;
-        }
-        if(particle->y > border_top) {
-            particle->y += center_height;
-        }
+    particle->x = random_int(0, grid_width - center_width, seed + 0);
+    particle->y = random_int(0, grid_height - center_height, seed + 1);
+    if(particle->x > border_left) {
+        particle->x += center_width;
     }
-    else {
-        particle->x = (float) (grid_width - (weight_center_x / total_static_particles));
-        particle->y = (float) (grid_height - (weight_center_y / total_static_particles));
-        // particle->x = grid_width / 2;
-        // particle->y = grid_height / 2;
-        debug = (int) particle->x;
+    if(particle->y > border_top) {
+        particle->y += center_height;
     }
 
     randomize_speed(particle, seed + 2, seed + 3);
@@ -240,28 +210,17 @@ void simulate() {
         tick(particles, ++tick_count);
 
       
-        int left, right, top, bottom, center_distance;
-        float debug_copy;
-        ullong total_static_particles_copy;
+        int left, right, top, bottom;
 
         cudaMemcpyFromSymbol(&left, border_left, sizeof(int));
         cudaMemcpyFromSymbol(&right, border_right, sizeof(int));
         cudaMemcpyFromSymbol(&top, border_top, sizeof(int));
         cudaMemcpyFromSymbol(&bottom, border_bottom, sizeof(int));
-        cudaMemcpyFromSymbol(&bottom, border_bottom, sizeof(int));
-        cudaMemcpyFromSymbol(&center_distance, smallest_distance_to_center, sizeof(int));
-        cudaMemcpyFromSymbol(&debug_copy, debug, sizeof(float));
-        cudaMemcpyFromSymbol(&total_static_particles_copy, total_static_particles, sizeof(ullong));
-
-        if(i % 10000 == 0) {
-            print(left << ", " << right << ", " << top << ", " << bottom << ", " << center_distance);
-            print(debug_copy);
-            print(total_static_particles_copy);
-        }
-        const int margin = 300;
-        if(CIRCLE_BORDER > -1 && center_distance < margin * margin) {
-            break;
+
+        if(i % 100 == 0) {
+            print(left << ", " << right << ", " << top << ", " << bottom);
         }
+        const int margin = 50;
         if(left < margin || right > grid_width - margin || top < margin || bottom > grid_height - margin) {
             break;
         }
@@ -272,14 +231,6 @@ void simulate() {
     cudaFree(particles);
 }
 
-__device__ float pythagoras(float a, float b) {
-    return a * a + b * b;
-}
-
-__device__ float pythagoras(Particle* particle) {
-    return pythagoras(particle->x - (float)(grid_width / 2), particle->y - (float)(grid_height / 2));
-}
-
 __global__ void particle_step(Particle* particles, int tick_count) {
     int i = blockIdx.x * blockDim.x + threadIdx.x; // particle index in the particles array
     Particle* particle = particles + i;
@@ -321,11 +272,6 @@ __global__ void particle_step(Particle* particles, int tick_count) {
     float modulo_y = fmod(particle->y, 1.0f);
     bool looping = true;
 
-    if(CIRCLE_BORDER > -1 && (int)(pythagoras(particle) + radius) >= CIRCLE_BORDER * CIRCLE_BORDER) {
-        make_static(particle, tick_count, modulo_x, modulo_y);
-        return;
-    }
-
     for(int dx = -ceil_radius; dx <= ceil_radius && looping; dx++) {
         for(int dy = -ceil_radius; dy <= ceil_radius && looping; dy++) {
             // calculate distance from center of the particle
@@ -336,7 +282,40 @@ __global__ void particle_step(Particle* particles, int tick_count) {
                 // position is within radius of the center
                 if(grid[(int)(particle->y - distance_y)][(int)(particle->x - distance_x)] >= 0) {
                     // hit another particle
-                    make_static(particle, tick_count, modulo_x, modulo_y);
+
+                    for(int dx2 = -ceil_radius; dx2 <= ceil_radius; dx2++) {
+                        for(int dy2 = -ceil_radius; dy2 <= ceil_radius; dy2++) {
+                            // calculate distance from center of the particle
+                            float distance_x2 = -dx2 + modulo_x;
+                            float distance_y2 = -dy2 + modulo_y;
+                
+                            if(distance_x2 * distance_x2 + distance_y2 * distance_y2 < radius * radius) {
+                                // calculate position in grid
+                                int absolute_x = (int)(particle->x - distance_x2);
+                                int absolute_y = (int)(particle->y - distance_y2);
+                    
+                                // if the absolute_x/y are within the grid
+                                if(absolute_x >= 0 && absolute_x < grid_width && absolute_y >= 0 && absolute_y < grid_height) {
+                                    // set the grid to being hit
+                                    grid[absolute_y][absolute_x] = tick_count;
+
+                                    /*
+                                        Because the program writes and reads from the same grid in a single tick,
+                                        the algorithm isn't completely deterministic. I could use two different 
+                                        grids and then copy values, but it doesn't feel necessary.
+                                    */
+                                }
+                            }
+                        }
+                    }
+                    
+                    atomicMin(&border_left, (int)(particle->x - radius));
+                    atomicMax(&border_right, (int)(particle->x + radius));
+                    atomicMin(&border_top, (int)(particle->y - radius));
+                    atomicMax(&border_bottom, (int)(particle->y + radius));
+                    
+                    // give the particle a random new position and speed
+                    randomize_particle(particle);
 
                     looping = false;
                     break;
@@ -347,55 +326,9 @@ __global__ void particle_step(Particle* particles, int tick_count) {
     }
 }
 
-__device__ void make_static(Particle* particle, int tick_count, float modulo_x, float modulo_y) {
-    // debug = sqrt(pythagoras(particle) - radius);
-
-    for(int dx2 = -ceil_radius; dx2 <= ceil_radius; dx2++) {
-        for(int dy2 = -ceil_radius; dy2 <= ceil_radius; dy2++) {
-            // calculate distance from center of the particle
-            float distance_x2 = -dx2 + modulo_x;
-            float distance_y2 = -dy2 + modulo_y;
-
-            if(distance_x2 * distance_x2 + distance_y2 * distance_y2 < radius * radius) {
-                // calculate position in grid
-                int absolute_x = (int)(particle->x - distance_x2);
-                int absolute_y = (int)(particle->y - distance_y2);
-    
-                // if the absolute_x/y are within the grid
-                if(absolute_x >= 0 && absolute_x < grid_width && absolute_y >= 0 && absolute_y < grid_height) {
-                    // set the grid to being hit
-                    grid[absolute_y][absolute_x] = tick_count;
-
-                    /*
-                        Because the program writes and reads from the same grid in a single tick,
-                        the algorithm isn't completely deterministic. I could use two different 
-                        grids and then copy values, but it doesn't feel necessary.
-                    */
-                }
-            }
-        }
-    }
-
-    if(CIRCLE_BORDER < 0) {
-        atomicMin(&border_left, (int)(particle->x - radius));
-        atomicMax(&border_right, (int)(particle->x + radius));
-        atomicMin(&border_top, (int)(particle->y - radius));
-        atomicMax(&border_bottom, (int)(particle->y + radius));
-    }
-    else {
-        atomicMin(&smallest_distance_to_center, (int)(pythagoras(particle) - radius));
-        atomicAdd(&total_static_particles, 1l);
-        atomicAdd(&weight_center_x, (ullong)particle->x);
-        atomicAdd(&weight_center_y, (ullong)particle->y);
-    }
-    
-    // give the particle a random new position and speed
-    randomize_particle(particle);
-}
-
 // perform one tick
 void tick(Particle* particles, int tick_count) {
-    const int threads_per_block = 16;
+    const int threads_per_block = 32;
     const int blocks = particle_count / threads_per_block;
 
     particle_step<<<blocks, threads_per_block>>>(particles, tick_count);
diff --git a/rust-visualiser/.gitignore b/rust-visualiser/.gitignore
index f0e3bca..53eaa21 100644
--- a/rust-visualiser/.gitignore
+++ b/rust-visualiser/.gitignore
@@ -1,2 +1,2 @@
 /target
-**/*.rs.bk
\ No newline at end of file
+**/*.rs.bk
diff --git a/rust-visualiser/src/main.rs b/rust-visualiser/src/main.rs
index 132ea13..21f57e9 100644
--- a/rust-visualiser/src/main.rs
+++ b/rust-visualiser/src/main.rs
@@ -53,7 +53,7 @@ fn save_as_image(grid_values: &[i32], grid_width: u32, grid_height: u32, reduced
         }
         else {
             // map tick_id to rgb
-            let quotient = 1000_000;
+            let quotient = 10_000;
             let base = tick_id + quotient / 10_000;
             let r = map_u8(base * 2633 / quotient);
             let g = map_u8(base * 4783 / quotient);
